package server

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	logrus "github.com/sirupsen/logrus"
)

type ClientCreateRequest struct {
	Key   string
	Value []byte
}

type ClientGetRequest struct {
	Key string
}

type ClientDeleteRequest struct {
	Key string
}

type ClientGetResponse struct {
	Value []byte
}

type ClusterStatusCode int

const (
	Ok             ClusterStatusCode = iota
	FailedNotFound ClusterStatusCode = iota
	FailedInternal ClusterStatusCode = iota
	Redirect       ClusterStatusCode = iota

	// Id will be generated by uuid
	RequestIDKey = "id"
)

type clusterRequest struct {
	Context context.Context
}

type ClusterCreateRequest struct {
	clusterRequest
	Key             string
	Value           []byte
	ResponseChannel chan<- ClusterCreateResponse
}

type ClusterGetRequest struct {
	clusterRequest
	Key             string
	ResponseChannel chan<- ClusterGetResponse
}

type ClusterDeleteRequest struct {
	clusterRequest
	Key             string
	ResponseChannel chan<- ClusterDeleteResponse
}

type ClusterResponse struct {
	StatusCode ClusterStatusCode
	Error      error
	LeaderName string
}

type ClusterCreateResponse struct {
	ClusterResponse
}

type ClusterGetResponse struct {
	ClusterResponse
	Value []byte
}

type ClusterDeleteResponse struct {
	ClusterResponse
}

type RequestsChannelsSub struct {
	ClusterCreateRequestChan <-chan ClusterCreateRequest
	ClusterGetRequestChan    <-chan ClusterGetRequest
	ClusterDeleteRequestChan <-chan ClusterDeleteRequest
}

type requestsChannelsPub struct {
	ClusterCreateRequestChan chan<- ClusterCreateRequest
	ClusterGetRequestChan    chan<- ClusterGetRequest
	ClusterDeleteRequestChan chan<- ClusterDeleteRequest
}

type Interface interface {
	Run() error
	Shutdown(ctx context.Context) error
	GetRequestsChannels() (*RequestsChannelsSub, error)
}

type ExternalServer struct {
	server              *http.Server
	router              *mux.Router
	requestsChannelsSub *RequestsChannelsSub
	requestsChannelsPub *requestsChannelsPub
	logger              *logrus.Entry
	nodesEndpoints      map[string]string
}

func New(endpoint string, nodesEndpoints map[string]string, logger *logrus.Entry) *ExternalServer {
	externalServer := &ExternalServer{
		logger:         logger,
		nodesEndpoints: nodesEndpoints,
	}

	r := mux.NewRouter()
	r.HandleFunc("/api/v1/object", externalServer.handleCreate).Methods("POST")
	r.HandleFunc("/api/v1/object", externalServer.handleDelete).Methods("DELETE")
	r.HandleFunc("/api/v1/object", externalServer.handleGet).Methods("GET")

	s := &http.Server{
		Handler:      r,
		Addr:         endpoint,
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}

	externalServer.router = r
	externalServer.server = s

	return externalServer
}

func (s *ExternalServer) Shutdown(ctx context.Context) error {
	defer func() {
		if s.requestsChannelsPub != nil {
			close(s.requestsChannelsPub.ClusterCreateRequestChan)
			close(s.requestsChannelsPub.ClusterGetRequestChan)
			close(s.requestsChannelsPub.ClusterDeleteRequestChan)
		}
	}()

	if err := s.server.Shutdown(ctx); err != nil {
		return err
	}

	return nil
}

func (s *ExternalServer) Run() error {
	if err := s.server.ListenAndServe(); err != http.ErrServerClosed {
		return err
	}

	return nil
}

func (s *ExternalServer) GetRequestsChannels() (*RequestsChannelsSub, error) {
	if s.requestsChannelsPub != nil {
		return nil, fmt.Errorf("request channel was already taken.")
	}

	createRequestChannel := make(chan ClusterCreateRequest)
	getRequestChannel := make(chan ClusterGetRequest)
	deleteRequestChannel := make(chan ClusterDeleteRequest)

	s.requestsChannelsPub = &requestsChannelsPub{
		ClusterCreateRequestChan: createRequestChannel,
		ClusterGetRequestChan:    getRequestChannel,
		ClusterDeleteRequestChan: deleteRequestChannel,
	}

	return &RequestsChannelsSub{
		ClusterCreateRequestChan: createRequestChannel,
		ClusterGetRequestChan:    getRequestChannel,
		ClusterDeleteRequestChan: deleteRequestChannel,
	}, nil
}

func (s *ExternalServer) handleCreate(w http.ResponseWriter, r *http.Request) {
	clientRequest := &ClientCreateRequest{}
	err := json.NewDecoder(r.Body).Decode(clientRequest)
	if err != nil || !s.validateClientCreateRequest(clientRequest) {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	ctx := context.WithValue(r.Context(), RequestIDKey, uuid.New().String())

	responseChannel := make(chan ClusterCreateResponse)
	s.requestsChannelsPub.ClusterCreateRequestChan <- ClusterCreateRequest{
		clusterRequest:  clusterRequest{Context: ctx},
		Key:             clientRequest.Key,
		Value:           clientRequest.Value,
		ResponseChannel: responseChannel,
	}

	clusterResponse := <-responseChannel

	switch clusterResponse.StatusCode {
	case Ok:
		w.WriteHeader(http.StatusOK)
		return
	case FailedInternal:
		w.WriteHeader(http.StatusInternalServerError)
		return
	case Redirect:
		leaderAddress, ok := s.nodesEndpoints[clusterResponse.LeaderName]
		if !ok {
			s.logger.Panicf("unable to get address of the leader %s in endpoints: %+v",
				clusterResponse.LeaderName, s.nodesEndpoints)
		}

		// Return StatusTemporaryRedirect, as only 307 and 308 statuses
		// force http clients to follow redirects with the same methods
		endpoint := "http://" + leaderAddress + "/create"
		http.Redirect(w, r, endpoint, http.StatusTemporaryRedirect)
		return
	}
}

func (s *ExternalServer) handleDelete(w http.ResponseWriter, r *http.Request) {
	clientRequest := &ClientDeleteRequest{}
	err := json.NewDecoder(r.Body).Decode(clientRequest)
	if err != nil || !s.validateClientDeleteRequest(clientRequest) {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	ctx := context.WithValue(r.Context(), RequestIDKey, uuid.New().String())

	responseChannel := make(chan ClusterDeleteResponse)
	s.requestsChannelsPub.ClusterDeleteRequestChan <- ClusterDeleteRequest{
		clusterRequest:  clusterRequest{Context: ctx},
		Key:             clientRequest.Key,
		ResponseChannel: responseChannel,
	}

	clusterResponse := <-responseChannel

	switch clusterResponse.StatusCode {
	case Ok:
		w.WriteHeader(http.StatusOK)
		return
	case FailedInternal:
		w.WriteHeader(http.StatusInternalServerError)
		return
	case FailedNotFound:
		w.WriteHeader(http.StatusNotFound)
		return
	case Redirect:
		leaderAddress, ok := s.nodesEndpoints[clusterResponse.LeaderName]
		if !ok {
			s.logger.Panicf("unable to get address of the leader %s in endpoints: %+v",
				clusterResponse.LeaderName, s.nodesEndpoints)
		}

		// Return StatusTemporaryRedirect, as only 307 and 308 statuses
		// force http clients to follow redirects with the same methods
		endpoint := "http://" + leaderAddress + "/delete"
		http.Redirect(w, r, endpoint, http.StatusTemporaryRedirect)
		return
	}
}

func (s *ExternalServer) handleGet(w http.ResponseWriter, r *http.Request) {
	clientRequest := &ClientGetRequest{}
	err := json.NewDecoder(r.Body).Decode(clientRequest)
	if err != nil || !s.validateClientGetRequest(clientRequest) {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	ctx := context.WithValue(r.Context(), RequestIDKey, uuid.New().String())

	responseChannel := make(chan ClusterGetResponse)
	s.requestsChannelsPub.ClusterGetRequestChan <- ClusterGetRequest{
		clusterRequest:  clusterRequest{Context: ctx},
		Key:             clientRequest.Key,
		ResponseChannel: responseChannel,
	}

	clusterResponse := <-responseChannel

	switch clusterResponse.StatusCode {
	case Ok:
		clientResponse := ClientGetResponse{
			Value: clusterResponse.Value,
		}
		buffer, err := json.Marshal(clientResponse)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		w.Write(buffer)
		return
	case FailedInternal:
		w.WriteHeader(http.StatusInternalServerError)
		return
	case FailedNotFound:
		w.WriteHeader(http.StatusNotFound)
		return
	case Redirect:
		leaderAddress, ok := s.nodesEndpoints[clusterResponse.LeaderName]
		if !ok {
			s.logger.Panicf("unable to get address of the leader %s in endpoints: %+v",
				clusterResponse.LeaderName, s.nodesEndpoints)
		}

		// Return StatusTemporaryRedirect, as only 307 and 308 statuses
		// force http clients to follow redirects with the same methods
		endpoint := "http://" + leaderAddress + "/get"
		http.Redirect(w, r, endpoint, http.StatusTemporaryRedirect)
		return
	}
}

func (s *ExternalServer) validateClientCreateRequest(request *ClientCreateRequest) bool {
	return request.Key != ""
}

func (s *ExternalServer) validateClientGetRequest(request *ClientGetRequest) bool {
	return request.Key != ""
}

func (s *ExternalServer) validateClientDeleteRequest(request *ClientDeleteRequest) bool {
	return request.Key != ""
}
